<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown/MathJax Editor</title>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            /* Set min-height to 100vh to handle initial full screen,
               but actual height will be controlled by JS for viewport adjustments */
            min-height: 100vh;
            overflow: hidden; /* Prevent body scroll, content areas will scroll */
            background-color: #f4f7f6;
            color: #333;
            padding-bottom: 0; /* Will be set by JS dynamically */
        }

        .container {
            flex-grow: 1; /* Allows the container to take available space */
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px; /* Spacing between textarea and render output */
            overflow: hidden; /* Important for containing scrolling children */
            /* Add this to give the container a base height that JS will override */
            height: calc(100vh - 50px); /* Initial guess for content height before JS takes over */
        }

        #markdownInput, #renderOutput {
            flex-grow: 1; /* Both take equal space within the container */
            width: 100%;
            border: 1px solid #dcdcdc;
            padding: 15px;
            box-sizing: border-box; /* Include padding/border in element's total width/height */
            font-size: 1rem;
            line-height: 1.6;
            border-radius: 8px;
            transition: border-color 0.2s ease-in-out;
            overflow-y: auto; /* Enable scrolling for content */
        }

        #markdownInput {
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', 'Monaco', monospace; /* Preferred coding font */
            resize: none; /* Disable manual textarea resize */
            background-color: #fff;
            color: #222;
        }

        #markdownInput:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        #renderOutput {
            background-color: #e9ecef;
            color: #333;
            /* Basic styling for rendered markdown content */
            font-family: sans-serif;
        }

        #renderOutput h1, #renderOutput h2, #renderOutput h3, #renderOutput h4, #renderOutput h5, #renderOutput h6 {
            color: #0056b3;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        #renderOutput p {
            margin-bottom: 1em;
        }

        #renderOutput pre {
            background-color: #f8f9fa;
            border: 1px solid #ced4da;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        #renderOutput code {
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', 'Monaco', monospace;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .hidden {
            display: none !important; /* Utility class to hide elements */
        }

        #toolbar {
            position: fixed; /* Keep it fixed at the bottom */
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping, force single line */
            overflow-x: auto; /* Enable horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            gap: 10px; /* Space between toolbar items */
            padding: 15px;
            background-color: #f0f0f0;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-start; /* Align items to the start */
            align-items: center; /* Vertically align items */
            min-height: 50px; /* Ensure toolbar has some height */
            box-sizing: border-box; /* Include padding in width/height */
            z-index: 999; /* Ensure it's above other content but below console */
        }

        #toolbar button {
            /* Prevent buttons from shrinking too much */
            flex-shrink: 0; 
            padding: 10px 18px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.95rem;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #toolbar button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        #toolbar button:active {
            background-color: #004085;
            transform: translateY(0);
        }

        /* --- Floating Console Styles --- */
        #floatingConsole {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px; /* Adjust as needed */
            height: 300px; /* Adjust as needed */
            background-color: #222;
            border: 1px solid #555;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000; /* Ensure it's on top of other content */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Hide scrollbars on the console div itself, content will scroll */
        }

        #floatingConsole.hidden {
            display: none;
        }

        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background-color: #333;
            color: #eee;
            font-weight: bold;
            border-bottom: 1px solid #555;
            cursor: grab; /* Indicate it's draggable if dragging functionality were added */
        }

        .console-close-btn {
            background: none;
            border: none;
            color: #eee;
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            margin: 0;
            transition: color 0.2s;
        }

        .console-close-btn:hover {
            color: #f00; /* Red on hover */
        }

        #consoleOutput {
            flex-grow: 1;
            overflow-y: auto; /* Enable scrolling for console messages */
            padding: 10px 15px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            color: #eee;
            white-space: pre-wrap; /* Preserve whitespace and wrap long lines */
            word-break: break-all; /* Break long words that exceed container width */
        }

        #consoleOutput .console-line {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        #consoleOutput .console-info {
            color: #eee; /* Default text color for info messages */
        }

        #consoleOutput .console-warn {
            color: #ffc107; /* Yellow for warnings */
        }

        #consoleOutput .console-error {
            color: #dc3545; /* Red for errors */
            font-weight: bold;
        }

        /* Basic responsiveness for smaller screens */
        @media (max-width: 768px) {
            #floatingConsole {
                width: 90%;
                height: 50vh; /* Use viewport height for better fitting on mobile */
                bottom: 10px;
                right: 5%;
                left: 5%;
            }
        }

        /* --- Print-specific Styles --- */
        @media print {
            #toolbar,
            #floatingConsole,
            #markdownInput, /* Also hide the input area when printing */
            #toggleViewBtn,
            #toggleConsoleBtn,
            #insertExampleBtn, /* Hide specific buttons if you want */
            #printBtn {
                display: none !important;
            }

            body {
                padding-bottom: 0 !important; /* Remove padding from toolbar space */
            }

            /* Ensure only the rendered output is visible and takes full width/height */
            .container {
                display: block; /* Change to block for print layout */
                padding: 0; /* Remove container padding for print */
                height: auto !important; /* Allow content to dictate height for print */
            }
            #renderOutput {
                display: block !important; /* Make sure it's always visible for print */
                width: auto !important;
                height: auto !important;
                flex-grow: 0 !important;
                border: none !important;
                box-shadow: none !important;
                background-color: transparent !important;
                overflow: visible !important; /* Allow content to print beyond initial view */
            }
        }
    </style>
    
    <script>
        window.MathJax = {
            tex: {
                // Keep inlineMath configured here, as it works well.
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                // Keep displayMath configured here. The Marked.js extension will help
                // ensure the HTML structure is clean for MathJax to pick these up.
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,         // Allow for escaped characters like \$
                processEnvironments: true,    // Allow for TeX environments like \begin{align}
                // Load common TeX packages like amsmath and newcommand for richer TeX support
                packages: {'[+]': ['ams', 'newcommand']}
            },
            options: {
                // Ensure MathJax skips processing inside these tags, which commonly hold code or raw input
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'annotation', 'annotation-xml']
            }
        };
    </script>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <textarea id="markdownInput" placeholder="Type your Markdown or MathJax here..."></textarea>
        
        <div id="renderOutput" class="hidden"></div>
    </div>

    <div id="toolbar">
        <button id="toggleViewBtn">Show Rendered</button>
        <button id="toggleConsoleBtn">Show Console</button>
        </div>

    <div id="floatingConsole" class="hidden">
        <div class="console-header">
            <span>Console</span>
            <button id="closeConsoleBtn" class="console-close-btn">&times;</button>
        </div>
        <div id="consoleOutput" class="console-output"></div>
    </div>

    <script>
        // Configure Marked.js with an extension to properly handle MathJax display blocks.
        // This ensures that $$...$$ content is wrapped in a div, which MathJax prefers for display equations,
        // rather than being potentially messed up by Markdown's paragraph processing.
        marked.use({
            extensions: [{
                name: 'mathBlock', // Custom extension name for block math
                level: 'block', // This is a block-level element (like paragraphs, lists, etc.)
                start(src) {
                    // This function helps marked.js quickly find potential matches.
                    // It looks for '$$' at the beginning of a line, optionally preceded by up to 3 spaces.
                    return src.match(/^ {0,3}\$\$/m);
                },
                tokenizer(src, tokens) {
                    // The regular expression to actually parse and capture the MathJax block.
                    // It looks for '$$', captures everything until the next '$$', and ensures it's a block.
                    const rule = /^ {0,3}\$\$([\\s\\S]*?)\$\$ *(?:\n|$)/;
                    const match = rule.exec(src);
                    if (match) {
                        const formula = match[1].trim(); // Extract the formula content, trimming whitespace
                        return {
                            type: 'mathBlock', // The type of token created by this extension
                            raw: match[0],     // The raw matched string from the input
                            formula: formula,  // The actual mathematical formula
                            tokens: []         // Math blocks should not contain nested Markdown tokens
                        };
                    }
                },
                renderer(token) {
                    // How to render this 'mathBlock' token into HTML.
                    // We wrap it in a div with a specific class for clarity, and re-add the $$ delimiters
                    // within the div so MathJax knows it's a display equation.
                    return `<div class="mathjax-display">$$\n${token.formula}\n$$</div>\n`;
                }
            }]
        });

        // --- Floating Console Logic ---
        // Store original console methods
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;

        // A temporary array to store messages logged before the custom console is initialized in DOM
        const pendingConsoleMessages = [];

        // This function will be called by our wrapped console methods to append to the custom console
        function appendToCustomConsole(type, args) {
            const message = Array.from(args).map(arg => {
                if (typeof arg === 'object' && arg !== null) {
                    try {
                        // Handle potential circular references with a replacer for JSON.stringify
                        const cache = new Set(); // Using a Set to detect circular refs
                        return JSON.stringify(arg, (key, value) => {
                            if (typeof value === 'object' && value !== null) {
                                if (cache.has(value)) {
                                    // Circular reference found, discard key
                                    return; // Return undefined to omit the value from the stringified output
                                }
                                // Store value in our collection
                                cache.add(value);
                            }
                            return value;
                        }, 2); // Pretty print with 2 spaces indentation
                    } catch (e) {
                        return String(arg); // Fallback for very complex objects or errors during stringify
                    }
                }
                return String(arg);
            }).join(' '); // Join all arguments with a space

            // If the consoleOutput element is ready, append the message
            if (window.consoleOutput) { 
                const line = document.createElement('div');
                line.classList.add('console-line', `console-${type}`);
                line.textContent = message;
                window.consoleOutput.appendChild(line);
                // Auto-scroll to the bottom to show the latest message
                window.consoleOutput.scrollTop = window.consoleOutput.scrollHeight;
            } else {
                // If consoleOutput is not yet in DOM, queue the message to be processed later
                pendingConsoleMessages.push({ type, message });
            }
        }

        // Override console methods to also write to our custom console
        console.log = function(...args) {
            appendToCustomConsole('info', args);
            originalConsoleLog.apply(console, args); // Also call the original console.log
        };

        console.warn = function(...args) {
            appendToCustomConsole('warn', args);
            originalConsoleWarn.apply(console, args); // Also call the original console.warn
        };

        console.error = function(...args) {
            appendToCustomConsole('error', args);
            originalConsoleError.apply(console, args); // Also call the original console.error
        };
        // --- End Floating Console Logic ---


        /**
         * The main application module, encapsulating all core functionalities.
         * It provides methods for rendering content, toggling views, and an API for add-ons.
         */
        const App = (() => {
            let markdownInput;
            let renderOutput;
            let toggleViewBtn;
            let toolbar;
            let container; // Reference to the container element
            let isCodeView = true; // State to track the current view (true for code view)

            /**
             * Renders the content from the markdownInput textarea into the renderOutput div.
             * Parses Markdown and then triggers MathJax typesetting.
             */
            const renderContent = () => {
                const markdownText = markdownInput.value;
                // Convert Markdown to HTML using Marked.js (which now uses our custom extension)
                const html = marked.parse(markdownText);
                renderOutput.innerHTML = html;
                console.log("Marked.js Output HTML:\n" + html); // Log Marked.js output HTML to console
                console.log("Rendered HTML updated."); // Log to console

                // Trigger MathJax typesetting for the newly rendered content.
                // This is crucial for MathJax to process mathematical expressions.
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([renderOutput])
                        .catch(err => console.error("MathJax typesetting error:", err)); // Log MathJax errors
                }
            };

            /**
             * Toggles between the code input view (textarea) and the rendered output view.
             * @param {string} [forceView] - Optional. 'code' to force code view, 'render' to force render view.
             */
            const toggleView = (forceView) => {
                const newIsCodeView = forceView === 'code' ? true : (forceView === 'render' ? false : !isCodeView);
                
                if (isCodeView === newIsCodeView) {
                    // No change in view state, do nothing
                    return;
                }

                isCodeView = newIsCodeView; // Update the view state

                if (isCodeView) {
                    // Switch to Code View
                    markdownInput.classList.remove('hidden');
                    renderOutput.classList.add('hidden');
                    toggleViewBtn.textContent = 'Show Rendered';
                    markdownInput.focus(); // Keep focus on the textarea
                    console.log("Switched to Code View.");
                } else {
                    // Switch to Rendered View
                    renderContent(); // Render content before showing it
                    markdownInput.classList.add('hidden');
                    renderOutput.classList.remove('hidden');
                    toggleViewBtn.textContent = 'Show Code';
                    console.log("Switched to Rendered View.");
                }
            };

            /**
             * Adds an HTML element or a string of HTML to the toolbar.
             * This method is part of the public API for add-ons to extend the toolbar.
             * @param {HTMLElement|string} elementOrHtmlString - The HTML element or string to add.
             */
            const addToolbarItem = (elementOrHtmlString) => {
                if (typeof elementOrHtmlString === 'string') {
                    // If it's an HTML string, create a temporary div to parse it
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = elementOrHtmlString;
                    while (tempDiv.firstChild) {
                        toolbar.appendChild(tempDiv.firstChild);
                    }
                } else if (elementOrHtmlString instanceof HTMLElement) {
                    // If it's already an HTMLElement, just append it
                    toolbar.appendChild(elementOrHtmlString);
                } else {
                    console.warn("App.addToolbarItem: Invalid item type. Must be HTMLElement or HTML string.", elementOrHtmlString);
                }
                // After adding an item, re-adjust layout if toolbar height changes
                adjustLayout();
            };

            /**
             * Returns the current content of the markdownInput textarea.
             * @returns {string} The current text content.
             */
            const getContent = () => markdownInput.value;

            /**
             * Sets the content of the markdownInput textarea and triggers a re-render
             * if the application is currently in render view.
             * @param {string} newContent - The new text content to set.
             */
            const setContent = (newContent) => {
                markdownInput.value = newContent;
                if (!isCodeView) {
                    renderContent(); // Re-render if in preview mode
                }
                console.log("Content updated.");
            };

            /**
             * Returns the current view state (true if in code view, false if in render view).
             * @returns {boolean}
             */
            const getIsCodeView = () => isCodeView;

            /**
             * Dynamically adjusts the height of the container and body padding
             * to account for the fixed toolbar, especially for mobile keyboard visibility.
             */
            const adjustLayout = () => {
                if (toolbar && container) {
                    const toolbarHeight = toolbar.offsetHeight;
                    const availableHeight = window.innerHeight; // Actual visual viewport height

                    // Set body padding to ensure content doesn't go under toolbar
                    document.body.style.paddingBottom = `${toolbarHeight}px`;

                    // Set container height directly based on available space
                    container.style.height = `${availableHeight - toolbarHeight}px`;
                    console.log(`Adjusted layout: Available Height = ${availableHeight}px, Toolbar Height = ${toolbarHeight}px, Container Height = ${availableHeight - toolbarHeight}px.`);
                }
            };

            /**
             * Initializes the application by getting DOM references, setting up event listeners,
             * and loading add-ons. This function is called once the DOM is ready.
             */
            const initApp = () => {
                // Get DOM elements
                markdownInput = document.getElementById('markdownInput');
                renderOutput = document.getElementById('renderOutput');
                toggleViewBtn = document.getElementById('toggleViewBtn');
                toolbar = document.getElementById('toolbar');
                container = document.querySelector('.container'); // Get reference to the container

                // --- Console DOM elements and Event Listeners ---
                window.floatingConsole = document.getElementById('floatingConsole');
                window.toggleConsoleBtn = document.getElementById('toggleConsoleBtn');
                window.closeConsoleBtn = document.getElementById('closeConsoleBtn');
                window.consoleOutput = document.getElementById('consoleOutput'); // Assign to window for global access

                // Process any pending messages that were logged before initApp (DOMContentLoaded)
                pendingConsoleMessages.forEach(msg => {
                    const line = document.createElement('div');
                    line.classList.add('console-line', `console-${msg.type}`);
                    line.textContent = msg.message;
                    window.consoleOutput.appendChild(line);
                });
                pendingConsoleMessages.length = 0; // Clear the queue after processing

                // Add event listeners for console toggle
                if (window.toggleConsoleBtn) {
                    window.toggleConsoleBtn.addEventListener('click', () => {
                        window.floatingConsole.classList.toggle('hidden');
                        console.log("Console visibility toggled.");
                    });
                }
                if (window.closeConsoleBtn) {
                    window.closeConsoleBtn.addEventListener('click', () => {
                        window.floatingConsole.classList.add('hidden');
                        console.log("Console closed.");
                    });
                }
                // --- End Console Init ---

                // Attach event listeners for main app functionality
                toggleViewBtn.addEventListener('click', () => toggleView()); // Call without forcing view

                // Optional: Live preview update when typing in code view, if in render mode
                markdownInput.addEventListener('input', () => {
                    if (!isCodeView) {
                        renderContent();
                    }
                });

                // Load add-ons dynamically from the 'addons' folder
                if (typeof addonList !== 'undefined' && Array.isArray(addonList)) {
                    addonList.forEach(addonFileName => {
                        const script = document.createElement('script');
                        script.src = `addons/${addonFileName}`; // Path to the add-on script
                        script.defer = true; // Defer script execution to not block parsing
                        script.onerror = () => console.error(`Failed to load addon: ${addonFileName}`);
                        document.body.appendChild(script);
                        console.log(`Attempting to load addon: ${addonFileName}`);
                    });
                } else {
                    console.warn("addonList not found or is not an array. No custom addons will be loaded.");
                }

                // Initial adjustment of layout after all initial elements (including toolbar) are in DOM
                adjustLayout();
                // Re-adjust on window resize (e.g., orientation change, keyboard show/hide)
                window.addEventListener('resize', adjustLayout);


                // Set initial focus and render initial empty content
                markdownInput.focus();
                renderContent(); // Render once on load to ensure MathJax is initialized, even if hidden
                console.log("Application initialized successfully!");
            };

            // Expose public methods/API for external access (e.g., from index.html and add-ons)
            return {
                initApp: initApp,
                addToolbarItem: addToolbarItem,
                getContent: getContent,
                setContent: setContent,
                renderContent: renderContent, // Allow add-ons to trigger a re-render
                toggleView: toggleView,       // Expose toggleView for external control
                getIsCodeView: getIsCodeView  // Expose current view state
            };
        })();

        // Assign initApp to the global window object so it can be called from index.html
        window.initApp = App.initApp;
        // Also, expose the entire App object globally for add-ons to use its API
        window.App = App;

        // Add-on list
        const addonList = [
            "exampleAddon.js",
            "printAddon.js"
        ];

        // Ensure the application initializes after all necessary scripts and DOM are loaded.
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof initApp === 'function') {
                initApp();
            } else {
                console.error("App initialization function (initApp) not found. Check embedded script.");
            }
        });
    </script>
</body>
</html>